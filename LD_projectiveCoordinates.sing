/*
This Singular file demonstrates generation of points, and point
doubling operations on ECC over GF(2^3) = GF(8).
*/

/*********
This is a Procedure to do point doubling
(x3, y3) = 2P(x1, y1). Proc takes a "list" P, where P[1] = x1, P[2] =
y1, and returns a list R = [x3, y3].
**********/
proc PplusP(list P){
list R;
number m, x3, y3;

//"List P is:";
//P;

m = P[1] + P[2]/P[1];
// a = alpha^2
x3 = m^2 + m + X^2; 
y3 = P[1]^2 + (m+1)*x3;

//"m, x3, y3 are:";
//m;
//x3;
//y3;

R = x3, y3;

//"List R:";
//R;

return(R);

}

/*********
This is a Procedure to do point addition
 Proc takes a "list" P and a "list Q", where P[1] = x1, P[2] =
y1, and returns a list R = [x3, y3].
**********/

proc PplusQ(list P,list Q){
list R;
number m, x3, y3;
if(Q[1] + P[1] == 0){
  printf("Point at infinity");
  return(0,0);
}
m = (Q[2] + P[2]) / (Q[1] + P[1]);
// a = alpha^2
x3 = m^2 + m + X^2 + Q[1] + P[1]; 
y3 = m*(P[1] + x3) + P[2] + x3;

R = x3, y3;

return(R);

}

/*********
This is a Procedure to do point doubling
(x2, y2) = 2P(x1, y1). Proc takes a "list" P, where P[1] = x1, P[2] =
y1, and returns a list R = [x3, y3]. a = X^2 b = 1
**********/
proc DL_PplusP(list P){
list R;
number m, x2, y2;

//"List P is:";
//P;

m = P[1] + P[2]/P[1];
// a = alpha^2
x2 = P[1]^2 + (1/P[1]^2);
y2 = (1/P[1]^2) + X^2*x2 + (P[2]^2 + 1)*(1+(1/P[1]^4));

R = x2, y2;

//"List R:";
//R;

return(R);

}


// Declare the ring over GF(8), with 2 variables, x and y

ring r = (2, X), (y, x), lp;
// This is the primitive polynomial given to us as a specification
// Here X = \alpha
minpoly = X^3 + X^2 + 1;
int i;
// print values of X
printf("PART A");
printf("printing values of alpha:");
for(i=0; i<8; i = i+1){
    printf("X%s is: %s",i,X^i);
}


// This is the non-singular elliptic curve also given to us as the spec
poly E = y^2 + x*y + x^3 + X^2*x^2 + 1;

// Now we will generate the points
int i;
// We use poly f to generate the points
poly f;

printf("when i = %s", 0);
// Substitute x = 0 in E
f = subst(E, x, 0);
printf("poly f is:");
f;
printf("poly f factorizes as follows:");
factorize(f);
"================================";

// 0 = special element, now we generate the remaining 7 elements
printf("PART B");
for(i=1; i<8; i = i+1){
printf("when x = %s", X^i);
f = subst(E, x, X^i);
printf("poly f after substitution of x =%s:", X^i);
f;
printf("poly f factorizes as:");
factorize(f);

"================================";
}
printf("");
// number = element in the field
number x1, y1;
list P;
list R;

x1 = X^6;
y1 = 1;
//x1 = 0;
//y1 = 1;
P = x1, y1;
R = PplusP(P);
R;
int j;
printf("");
printf("SCHROEPPEL");
printf("--------------------------");
printf("Generating All the points with primitive element P: (X^6,1)");
"Point 1: ";
printf("P = (%s, %s)", P[1], P[2]);
for(j = 1; j<14; j = j+1){
    // doubling point first
    printf("Point %s: ",j + 1);
    if( j == 1){
    R = PplusP(P);
    
    printf("P = (%s, %s)", R[1], R[2]);
    }
    else{
    
      R =  PplusQ(P,R);
      printf("P = (%s, %s)", R[1], R[2]);
    }
    
}


printf("");
printf("LOPEZ DAHAB POINT DOUBLING");
printf("--------------------------");
printf("Generating All the points with primitive element P: (X^6,1)");
"Point 1: ";
printf("P = (%s, %s)", P[1], P[2]);
for(j = 1; j<16; j = j+1){
    // doubling point first
    printf("Point %s: ",j + 1);
    if( j == 1){
    R = DL_PplusP(P);
    
    printf("P = (%s, %s)", R[1], R[2]);
    }
    else{
    
      R =  PplusQ(P,R);
      printf("P = (%s, %s)", R[1], R[2]);
    }
    
}

"";
int p;
"printing only doubled points on the field using DL";
p = 2;
for(j = 1; j<4; j = j+1){
    P = DL_PplusP(P);
    printf("Point %s= (%s, %s)",p, P[1], P[2]);
    p = p*2;
}

"";
//veryfing POINT DOUBLING
list D,R;
number d1;
number d2;

d1 = X;
d2 = 1;
D = d1,d2;
R = DL_PplusP(D);
"SINGULAR POINT DOUBLING point 1";
"-------------------------------";
printf("Doubling point D :(%s), (%s)", D[1], D[2]);
printf("D^2= (%s), (%s)", R[1], R[2]);


// Verifying Doubling point in hardware
"";
"HARDWARE VERIFICATION point 1";
"-----------------------------";
// X2 = 110, Y2 = 001 Z2 = 100 values obtained in verilog
number X3,Y3,Z3;
X3 = X^2 + X;
Y3 = 1;
Z3 = X^2;
"making sure the values in circuit are the same dividing by X/Z3 Y/Z3^2:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
printf("Y3/Z3 = %s",Y3/(Z3^2));

"";
"SINGULAR POINT DOUBLING point 2";
"-------------------------------";
// point alpha^2 + 1 , alpha + 1
d1 = X^2 + X + 1;
d2 = X + 1;
D = d1,d2;
R = DL_PplusP(D);
printf("Doubling point D :(%s), (%s)", D[1], D[2]);
printf("D^2 = (%s), (%s)", R[1], R[2]);

// verilog output:X2 = 101, Y2 = 111 Z2 = 010
X3 = X^2 + 1;
Y3 = X^2 + X + 1;
Z3 = X;
"";
"HARDWARE VERIFICATION point 2";
"-----------------------------";
"making sure the values in circuit are the same dividing by X/Z3 Y/Z3^2:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
// Double the point Z3
printf("Y3/(Z3^2) = %s",Y3/(Z3^2));

"";
number d3,d4;
list D2;
d1 = X^2 + X;
d2 = 1;
D = d1,d2;
d3 = X^2 + X + 1;
d4 = X;
D2 = d3,d4;

"SINGULAR POINT ADDITION getting point 3";
"---------------------------------------";
R = PplusQ(D,D2);
printf("adding points D :(%s), (%s) and D2 :(%s), (%s)", D[1], D[2], D2[1], D2[2]);
printf("D + D2 = (%s), (%s)", R[1], R[2]);

"HARDWARE POINT ADDITION getting point 3";
"----------------------------------------";
//  values obtained in verilog: X2 = 011, Y2 = 000 Z2 = 001
number X2,Y2,Z2;
X2 = X + 1;
Y2 = 0;
Z2 = 1;

"making sure the values in circuit are the same dividing by X/Z3 Y/Z3^2:";
printf("(X2,Y2,Z2) = (%s,%s,%s)",X3,Y3,Z3);
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2 = %s",Y2/(Z2^2));

d1 = X^2 + X;
d2 = 1;
D = d1,d2;
d3 = X^2 + X + 1;
d4 = X^2 + 1;
D2 = d3,d4;

"SINGULAR POINT ADDITION getting point 13";
"---------------------------------------";
R = PplusQ(D,D2);
printf("adding points D :(%s), (%s) and D2 :(%s), (%s)", D[1], D[2], D2[1], D2[2]);
printf("D + D2 = (%s), (%s)", R[1], R[2]);

"HARDWARE POINT ADDITION getting point 13";
"----------------------------------------";
// values obtained in verilog:  X2 = 110, Y2 = 111 Z2 = 001

X2 = X^2 + X;
Y2 = X^2 + X + 1;
Z2 = 1;

"making sure the values in circuit are the same dividing by X/Z3 Y/Z3^2:";
printf("(X2,Y2,Z2) = (%s,%s,%s)",X2,Y2,Z2);
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2^2 = %s",Y2/(Z2^2));

"";
X2 = X^2;
Y2 = X^2 + X + 1;
Z2 = X + 1;
"HARDWARE GENERATION OF POINTS";
"Point 2";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2^2 = %s",Y2/(Z2^2));

"";
X2 = X^2 + X + 1;
Y2 = 0;
Z2 = X^2 + X;
"Point 3";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2^2 = %s",Y2/(Z2^2));

"";
X2 = X^2 + X + 1;
Y2 = X^2 + 1;
Z2 = X^2;
"Point 4";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2^2 = %s",Y2/(Z2^2));

"";
X2 = X;
Y2 = X;
Z2 = X + 1;
"Point 9";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2 = %s",Y2/(Z2^2));

"";
X2 = X;
Y2 = X;
Z2 = X^2;
"Point 13";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2 = %s",Y2/(Z2^2));

// Key generation select d as 2 to use point doubling to calculate
// e2
proc Keygen(list e1, int d){
list e2;
for(j = 1; j<d; j = j+1){
    // doubling point first
    //printf("Point %s: ",j + 1);
    if( j == 1){
    e2 = PplusP(e1);    
    //printf("P = (%s, %s)", e2[1], e2[2]);
    }
    else{   
      e2 =  PplusQ(e1,e2);
      //printf("P = (%s, %s)", e2[1], e2[2]);
    }   
}

return(e2);

}

// Key generation select d as 2 to use point doubling to calculate
// e2
proc Encrypt(list e1,list e2, list P, int r){
list C1,C2;
int j;
for(j = 1; j<r; j = j+1){
    // doubling point first
    //printf("Point %s: ",j + 1);
    if( j == 1){
    C1 = PplusP(e1);    
    //printf("P = (%s, %s)", e2[1], e2[2]);
    }
    else{   
      C1 =  PplusQ(e1,C1);
      //printf("P = (%s, %s)", e2[1], e2[2]);
    }   
}
int j;
for(j = 1; j<r; j = j+1){
    // doubling point first
    //printf("Point %s: ",j + 1);
    if( j == 1){
    C2 = PplusP(e2);    
    //printf("P = (%s, %s)", e2[1], e2[2]);
    }
    else{   
      C2 =  PplusQ(e2,C2);
      //printf("P = (%s, %s)", e2[1], e2[2]);
    }   
}

C2 = PplusQ(P,C2);

return(C1,C2);

}

proc Decrypt(list C1,list C2, int d){
list C3, C1_inverse,PlainText;
int j;
for(j = 1; j<d; j = j+1){
    // doubling point first
    //printf("Point %s: ",j + 1);
    if( j == 1){
    C3 = PplusP(C1);    
    //printf("P = (%s, %s)", e2[1], e2[2]);
    }
    else{   
      C3 =  PplusQ(C1,C3);
      //printf("P = (%s, %s)", e2[1], e2[2]);
    }   
}
number C1_inverse_1,C1_inverse_2;
"C1 times d";
C3;
"------";
C1_inverse = C3[1],C3[1] + C3[2];
"C1 inverse";
C1_inverse;
"---------";
PlainText = PplusQ(C2,C1_inverse);
return(PlainText);

}

print(" ");
print("LD ECC ENCRYPTION / DECRYPTION");
printf("El gamal Encipherment");
list e1,e2,PlainText,Encription,Decription,C1,C2;
number e1_1,e2_2,p1,p2;

e1_1 = X^6;
e2_2 = 1;
e1 = e1_1, e2_2;
int d;
d = 4;
e2 = Keygen(e1,d);
printf("d = %s",d);
printf("e1 = (%s, %s)", e1[1], e1[2]);
printf("e2 = (%s, %s)", e2[1], e2[2]);

p1 = X + 1;
p2 = X + 1;
PlainText = p1,p2;
printf("Plain text Value = (%s, %s)", p1, p2);

int r_token;
r_token = 3;
printf("r = %s",r_token);
Encription = Encrypt(e1,e2,PlainText,r_token);
//"C1 is:";
"";
C1 = Encription[1];
C2 = Encription[2];
"C1 and C2:";
printf("Encripted Value = (%s), (%s)", C1, C2);

Decription = Decrypt(C1,C2, 4);
printf("Decripted Value = (%s, %s)", Decription[1], Decription[2]);

"";
"VERIFYING C1 IN HARDWARE in singular is supposed to be (A5,0)";
X3 = X^2 + X + 1;
Y3 = 0;
Z3 = X^2+X;
"making sure the values are the same dividing by Z3:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
printf("Y3/Z3 = %s",Y3/Z3^2);

"";
"VERIFYING C2 IN HARDWARE in singular is supposed to be (A3,A5) or (X2 +1 , X + 1)";
X3 =  X^2;
Y3 = X^2 + 1;
Z3 = X^2 + X;
"making sure the values are the same dividing by Z3:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
printf("Y3/Z3 = %s",Y3/Z3^2);


"";
"VERIFYING PLAIN TEXT BACK IN HARDWARE  (X +1 , X + 1)";
X3 =  X + 1;
Y3 = X + 1;
Z3 = 1;
"making sure the values are the same dividing by Z3:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
printf("Y3/Z3 = %s",Y3/Z3^2);

/*
This Singular file demonstrates generation of points, and point
doubling operations on ECC over GF(2^3) = GF(8).
*/

/*********
This is a Procedure to do point doubling
(x3, y3) = 2P(x1, y1). Proc takes a "list" P, where P[1] = x1, P[2] =
y1, and returns a list R = [x3, y3].
**********/
proc PplusP(list P){
list R;
number m, x3, y3;

//"List P is:";
//P;

m = P[1] + P[2]/P[1];
// a = alpha^2
x3 = m^2 + m + X^2; 
y3 = P[1]^2 + (m+1)*x3;

//"m, x3, y3 are:";
//m;
//x3;
//y3;

R = x3, y3;

//"List R:";
//R;

return(R);

}

/*********
This is a Procedure to do point addition
 Proc takes a "list" P and a "list Q", where P[1] = x1, P[2] =
y1, and returns a list R = [x3, y3].
**********/

proc PplusQ(list P,list Q){
list R;
number m, x3, y3;
if(Q[1] + P[1] == 0){
  printf("Point at infinity");
  return(0,0);
}
m = (Q[2] + P[2]) / (Q[1] + P[1]);
// a = alpha^2
x3 = m^2 + m + X^2 + Q[1] + P[1]; 
y3 = m*(P[1] + x3) + P[2] + x3;

R = x3, y3;

return(R);

}

/*********
This is a Procedure to do point doubling
(x2, y2) = 2P(x1, y1). Proc takes a "list" P, where P[1] = x1, P[2] =
y1, and returns a list R = [x3, y3]. a = X^2 b = 1
**********/
proc DL_PplusP(list P){
list R;
number m, x2, y2;

//"List P is:";
//P;

m = P[1] + P[2]/P[1];
// a = alpha^2
x2 = P[1]^2 + (1/P[1]^2);
y2 = (1/P[1]^2) + X^2*x2 + (P[2]^2 + 1)*(1+(1/P[1]^4));

R = x2, y2;

//"List R:";
//R;

return(R);

}


// Declare the ring over GF(8), with 2 variables, x and y

ring r = (2, X), (y, x), lp;
// This is the primitive polynomial given to us as a specification
// Here X = \alpha
minpoly = X^3 + X^2 + 1;
int i;
// print values of X
printf("PART A");
printf("printing values of alpha:");
for(i=0; i<8; i = i+1){
    printf("X%s is: %s",i,X^i);
}


// This is the non-singular elliptic curve also given to us as the spec
poly E = y^2 + x*y + x^3 + X^2*x^2 + 1;

// Now we will generate the points
int i;
// We use poly f to generate the points
poly f;

printf("when i = %s", 0);
// Substitute x = 0 in E
f = subst(E, x, 0);
printf("poly f is:");
f;
printf("poly f factorizes as follows:");
factorize(f);
"================================";

// 0 = special element, now we generate the remaining 7 elements
printf("PART B");
for(i=1; i<8; i = i+1){
printf("when x = %s", X^i);
f = subst(E, x, X^i);
printf("poly f after substitution of x =%s:", X^i);
f;
printf("poly f factorizes as:");
factorize(f);

"================================";
}
printf("");
// number = element in the field
number x1, y1;
list P;
list R;

x1 = X^6;
y1 = 1;
//x1 = 0;
//y1 = 1;
P = x1, y1;
R = PplusP(P);
R;
int j;
printf("");
printf("SCHROEPPEL");
printf("--------------------------");
printf("Generating All the points with primitive element P: (X^6,1)");
"Point 1: ";
printf("P = (%s, %s)", P[1], P[2]);
for(j = 1; j<14; j = j+1){
    // doubling point first
    printf("Point %s: ",j + 1);
    if( j == 1){
    R = PplusP(P);
    
    printf("P = (%s, %s)", R[1], R[2]);
    }
    else{
    
      R =  PplusQ(P,R);
      printf("P = (%s, %s)", R[1], R[2]);
    }
    
}


printf("");
printf("LOPEZ DAHAB POINT DOUBLING");
printf("--------------------------");
printf("Generating All the points with primitive element P: (X^6,1)");
"Point 1: ";
printf("P = (%s, %s)", P[1], P[2]);
for(j = 1; j<16; j = j+1){
    // doubling point first
    printf("Point %s: ",j + 1);
    if( j == 1){
    R = DL_PplusP(P);
    
    printf("P = (%s, %s)", R[1], R[2]);
    }
    else{
    
      R =  PplusQ(P,R);
      printf("P = (%s, %s)", R[1], R[2]);
    }
    
}

"";
int p;
"printing only doubled points on the field using DL";
p = 2;
for(j = 1; j<4; j = j+1){
    P = DL_PplusP(P);
    printf("Point %s= (%s, %s)",p, P[1], P[2]);
    p = p*2;
}

"";
//veryfing POINT DOUBLING
list D,R;
number d1;
number d2;

d1 = X;
d2 = 1;
D = d1,d2;
R = DL_PplusP(D);
"SINGULAR POINT DOUBLING point 1";
"-------------------------------";
printf("Doubling point D :(%s), (%s)", D[1], D[2]);
printf("D^2= (%s), (%s)", R[1], R[2]);


// Verifying Doubling point in hardware
"";
"HARDWARE VERIFICATION point 1";
"-----------------------------";
// X2 = 110, Y2 = 001 Z2 = 100 values obtained in verilog
number X3,Y3,Z3;
X3 = X^2 + X;
Y3 = 1;
Z3 = X^2;
"making sure the values in circuit are the same dividing by X/Z3 Y/Z3^2:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
printf("Y3/Z3 = %s",Y3/(Z3^2));

"";
"SINGULAR POINT DOUBLING point 2";
"-------------------------------";
// point alpha^2 + 1 , alpha + 1
d1 = X^2 + X + 1;
d2 = X + 1;
D = d1,d2;
R = DL_PplusP(D);
printf("Doubling point D :(%s), (%s)", D[1], D[2]);
printf("D^2 = (%s), (%s)", R[1], R[2]);

// verilog output:X2 = 101, Y2 = 111 Z2 = 010
X3 = X^2 + 1;
Y3 = X^2 + X + 1;
Z3 = X;
"";
"HARDWARE VERIFICATION point 2";
"-----------------------------";
"making sure the values in circuit are the same dividing by X/Z3 Y/Z3^2:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
// Double the point Z3
printf("Y3/(Z3^2) = %s",Y3/(Z3^2));

"";
number d3,d4;
list D2;
d1 = X^2 + X;
d2 = 1;
D = d1,d2;
d3 = X^2 + X + 1;
d4 = X;
D2 = d3,d4;

"SINGULAR POINT ADDITION getting point 3";
"---------------------------------------";
R = PplusQ(D,D2);
printf("adding points D :(%s), (%s) and D2 :(%s), (%s)", D[1], D[2], D2[1], D2[2]);
printf("D + D2 = (%s), (%s)", R[1], R[2]);

"HARDWARE POINT ADDITION getting point 3";
"----------------------------------------";
//  values obtained in verilog: X2 = 011, Y2 = 000 Z2 = 001
number X2,Y2,Z2;
X2 = X + 1;
Y2 = 0;
Z2 = 1;

"making sure the values in circuit are the same dividing by X/Z3 Y/Z3^2:";
printf("(X2,Y2,Z2) = (%s,%s,%s)",X3,Y3,Z3);
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2 = %s",Y2/(Z2^2));

d1 = X^2 + X;
d2 = 1;
D = d1,d2;
d3 = X^2 + X + 1;
d4 = X^2 + 1;
D2 = d3,d4;

"SINGULAR POINT ADDITION getting point 13";
"---------------------------------------";
R = PplusQ(D,D2);
printf("adding points D :(%s), (%s) and D2 :(%s), (%s)", D[1], D[2], D2[1], D2[2]);
printf("D + D2 = (%s), (%s)", R[1], R[2]);

"HARDWARE POINT ADDITION getting point 13";
"----------------------------------------";
// values obtained in verilog:  X2 = 110, Y2 = 111 Z2 = 001

X2 = X^2 + X;
Y2 = X^2 + X + 1;
Z2 = 1;

"making sure the values in circuit are the same dividing by X/Z3 Y/Z3^2:";
printf("(X2,Y2,Z2) = (%s,%s,%s)",X2,Y2,Z2);
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2^2 = %s",Y2/(Z2^2));

"";
X2 = X^2;
Y2 = X^2 + X + 1;
Z2 = X + 1;
"HARDWARE GENERATION OF POINTS";
"Point 2";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2^2 = %s",Y2/(Z2^2));

"";
X2 = X^2 + X + 1;
Y2 = 0;
Z2 = X^2 + X;
"Point 3";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2^2 = %s",Y2/(Z2^2));

"";
X2 = X^2 + X + 1;
Y2 = X^2 + 1;
Z2 = X^2;
"Point 4";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2^2 = %s",Y2/(Z2^2));

"";
X2 = X;
Y2 = X;
Z2 = X + 1;
"Point 9";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2 = %s",Y2/(Z2^2));

"";
X2 = X;
Y2 = X;
Z2 = X^2;
"Point 13";
printf("X2/Z2 = %s",X2/Z2);
printf("Y2/Z2 = %s",Y2/(Z2^2));

// Key generation select d as 2 to use point doubling to calculate
// e2
proc Keygen(list e1, int d){
list e2;
for(j = 1; j<d; j = j+1){
    // doubling point first
    //printf("Point %s: ",j + 1);
    if( j == 1){
    e2 = PplusP(e1);    
    //printf("P = (%s, %s)", e2[1], e2[2]);
    }
    else{   
      e2 =  PplusQ(e1,e2);
      //printf("P = (%s, %s)", e2[1], e2[2]);
    }   
}

return(e2);

}

// Key generation select d as 2 to use point doubling to calculate
// e2
proc Encrypt(list e1,list e2, list P, int r){
list C1,C2;
int j;
for(j = 1; j<r; j = j+1){
    // doubling point first
    //printf("Point %s: ",j + 1);
    if( j == 1){
    C1 = PplusP(e1);    
    //printf("P = (%s, %s)", e2[1], e2[2]);
    }
    else{   
      C1 =  PplusQ(e1,C1);
      //printf("P = (%s, %s)", e2[1], e2[2]);
    }   
}
int j;
for(j = 1; j<r; j = j+1){
    // doubling point first
    //printf("Point %s: ",j + 1);
    if( j == 1){
    C2 = PplusP(e2);    
    //printf("P = (%s, %s)", e2[1], e2[2]);
    }
    else{   
      C2 =  PplusQ(e2,C2);
      //printf("P = (%s, %s)", e2[1], e2[2]);
    }   
}

C2 = PplusQ(P,C2);

return(C1,C2);

}

proc Decrypt(list C1,list C2, int d){
list C3, C1_inverse,PlainText;
int j;
for(j = 1; j<d; j = j+1){
    // doubling point first
    //printf("Point %s: ",j + 1);
    if( j == 1){
    C3 = PplusP(C1);    
    //printf("P = (%s, %s)", e2[1], e2[2]);
    }
    else{   
      C3 =  PplusQ(C1,C3);
      //printf("P = (%s, %s)", e2[1], e2[2]);
    }   
}
number C1_inverse_1,C1_inverse_2;
"C1 times d";
C3;
"------";
C1_inverse = C3[1],C3[1] + C3[2];
"C1 inverse";
C1_inverse;
"---------";
PlainText = PplusQ(C2,C1_inverse);
return(PlainText);

}

print(" ");
print("LD ECC ENCRYPTION / DECRYPTION");
printf("El gamal Encipherment");
list e1,e2,PlainText,Encription,Decription,C1,C2;
number e1_1,e2_2,p1,p2;

e1_1 = X^6;
e2_2 = 1;
e1 = e1_1, e2_2;
int d;
d = 4;
e2 = Keygen(e1,d);
printf("d = %s",d);
printf("e1 = (%s, %s)", e1[1], e1[2]);
printf("e2 = (%s, %s)", e2[1], e2[2]);

p1 = X + 1;
p2 = X + 1;
PlainText = p1,p2;
printf("Plain text Value = (%s, %s)", p1, p2);

int r_token;
r_token = 3;
printf("r = %s",r_token);
Encription = Encrypt(e1,e2,PlainText,r_token);
//"C1 is:";
"";
C1 = Encription[1];
C2 = Encription[2];
"C1 and C2:";
printf("Encripted Value = (%s), (%s)", C1, C2);

Decription = Decrypt(C1,C2, 4);
printf("Decripted Value = (%s, %s)", Decription[1], Decription[2]);

"";
"VERIFYING C1 IN HARDWARE in singular is supposed to be (A5,0)";
X3 = X^2 + X + 1;
Y3 = 0;
Z3 = X^2+X;
"making sure the values are the same dividing by Z3:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
printf("Y3/Z3 = %s",Y3/Z3^2);

"";
"VERIFYING C2 IN HARDWARE in singular is supposed to be (A3,A5) or (X2 +1 , X + 1)";
X3 =  X^2;
Y3 = X^2 + 1;
Z3 = X^2 + X;
"making sure the values are the same dividing by Z3:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
printf("Y3/Z3 = %s",Y3/Z3^2);


"";
"VERIFYING PLAIN TEXT BACK IN HARDWARE  (X +1 , X + 1)";
X3 =  X + 1;
Y3 = X + 1;
Z3 = 1;
"making sure the values are the same dividing by Z3:";
printf("(X3,Y3,Z3) = (%s,%s,%s)",X3,Y3,Z3);
printf("X3/Z3 = %s",X3/Z3);
printf("Y3/Z3 = %s",Y3/Z3^2);

